VERSION='0.1.0'
APPNAME='CppUnit2'
srcdir = '.'
blddir = 'build'

import Options
import Logs
import UnitTest
import Utils
import os.path
import sys
import glob

CPPUT_EXAMPLES = '''
    checking_assertions
    ignore_failure_demo
    input_test
    light_fixture
    log_demo
    parametrized_test
    stringize_demo
    test_function
    '''.split()

BROKEN_CPPUT_EXAMPLES = '''
    input_based_test
    opentest_demo
    table_fixture
    '''.split()

def _get_example_dirs():
    return [ os.path.join( 'examples', d )
             for d in CPPUT_EXAMPLES ]

def _get_main_script_dir():
    """Gets the path of the directory containing this script."""
    # The main script path is only valid once the it has been executed, hence this can not be a global var.
    assert Utils.g_module is not None
    return os.path.split( Utils.g_module.root_path )[0]

def _fix_import_path():
    """Adds the main script directory to be able to import waftools modules."""
    import_dir = _get_main_script_dir()
    if import_dir not in sys.path:
        sys.path.append( import_dir )

def _get_tool_dir():
    return os.path.join( main_script_dir, 'waftools' )

def set_options(opt):
    """Always called first during the build."""
    _fix_import_path()
    import waftools.log_output
    waftools.log_output.set_options( opt )

    # Adds command-line options for compiler
    opt.tool_options('compiler_cxx')

    # from compiler_cxx tools, set_options
    import Tools.ccroot as ccroot
    opt.add_option('-d', '--debug-level',
        action = 'store',
        default = ccroot.DEBUG_LEVELS.RELEASE,
        help = "Specify the debug level, does nothing if CXXFLAGS is set in the environment. [Allowed Values: '%s'] " % "', '".join(ccroot.DEBUG_LEVELS.ALL) +
               "[default: %default]",
        choices = ccroot.DEBUG_LEVELS.ALL,
        dest = 'debug_level')

def init():
    """Called set_options() once the command-line has been parsed.
       Command-line options value are accessed through Options.options.
    """
    import waftools.log_output
    waftools.log_output.init()

    
def configure(conf):
    # There is a link issue with msvc 9!
    conf.env['MSVC_VERSIONS'] = ['msvc 8.0']

    # CXX=g++-3.0 ./waf.py configure will use g++-3.0 instead of 'g++'
    conf.check_tool('compiler_cxx')

    # Select debug/optimize flags
    debug_level = Options.options.debug_level.upper()
    conf.env.append_unique('CXXFLAGS', conf.env['CXXFLAGS_' + debug_level])

    compiler = conf.env['COMPILER_CXX']
    if compiler == 'msvc':  # Microsoft Visual Studio specifics
        # Select run-time library variant
        if 'DEBUG' in debug_level:
            crt_variant = 'MULTITHREADED_DLL_DBG'
        else:
            crt_variant = 'MULTITHREADED_DLL'
        # MULTITHREADED, MULTITHREADED_DLL, MULTITHREADED_DBG, MULTITHREADED_DLL_DBG
        conf.env.append_unique('CPPFLAGS', conf.env['CPPFLAGS_CRT_' + crt_variant])
        conf.env.append_unique('CPPDEFINES', conf.env['CPPDEFINES_CRT_' + crt_variant])
    
    ## batched builds can be enabled by including the module optim_cc
    # conf.check_tool('batched_cc')
   
   
# WAF command:

def build(bld):
    # process subfolders from here
    bld.add_subdirs('''src/cpptl 
                       src/cpput 
                       src/cpputtest''')

    bld.add_subdirs( _get_example_dirs() )

def gen_examples_wscript(ctx):
    for example_dir in _get_example_dirs():
        wscript_path = os.path.join( example_dir, 'wscript_build' )
        sources = glob.glob( os.path.join( example_dir, '*.cpp' ) )
        Logs.info( 'Generating "%s"' % wscript_path )
        open( wscript_path, 'wb' ).write( """\
#! /usr/bin/env python
# encoding: utf-8
# Baptiste Lepilleur, 2009

bld.new_task_gen(
    features = 'cxx cprogram',
    source = '''%(sources)s''',
    includes = '../.. ../../include',               # for examples/common
    uselib_local = 'cpptl cpput',
    name = 'example_%(name)s',
    target = 'example_%(name)s' )
""" % {
    'sources': ' '.join( [os.path.basename(s) for s in sources] ),
    'name': os.path.basename( example_dir )
    } )

def _fix_python_source( path, is_dry_run = True, verbose = True ):
    """Makes sure that all sources have unix EOL and replace tabs with 4 spaces."""
    from waftools import reindent
    if not os.path.isfile( path ):
        raise ValueError( 'Path "%s" is not a file' % path )
    try:
        f = open(path, 'rb')
    except IOError, msg:
        print >> sys.stderr, "%s: I/O Error: %s" % (file, str(msg))
        return False

    if verbose:
        print '%s =>' % path, 
    try:
        r = reindent.Reindenter(f)
    finally:
        f.close()
    if r.run(): # File need to be fixed ?
        if not is_dry_run:
            f = open(path, "wb")
            try:
                r.write(f)
            finally:
                f.close()
        if verbose:
            print is_dry_run and ' NEED FIX' or ' FIXED'
    elif verbose:
        print ' OK'
    return True

def _fix_source_eol( path, is_dry_run = True, verbose = True, eol = '\n' ):
    """Makes sure that all sources have the specified eol sequence (default: unix)."""
    if not os.path.isfile( path ):
        raise ValueError( 'Path "%s" is not a file' % path )
    try:
        f = open(path, 'rb')
    except IOError, msg:
        print >> sys.stderr, "%s: I/O Error: %s" % (file, str(msg))
        return False
    try:
        raw_lines = f.readlines()
    finally:
        f.close()
    fixed_lines = [line.rstrip('\r\n') + eol for line in raw_lines]
    if raw_lines != fixed_lines:
        print '%s =>' % path,
        if not is_dry_run:
            f = open(path, "wb")
            try:
                f.writelines(fixed_lines)
            finally:
                f.close()
        if verbose:
            print is_dry_run and ' NEED FIX' or ' FIXED'
    return True
    
    

def _do_fix( is_dry_run = True ):
    from waftools import antglob
    python_sources = antglob.glob( '.',
        includes = '**/*.py **/wscript **/wscript_build',
        excludes = antglob.default_excludes + './waf.py',
        prune_dirs = antglob.prune_dirs + 'waf-* ./build' )
    for path in python_sources:
        _fix_python_source( path, is_dry_run )

    cpp_sources = antglob.glob( '.',
        includes = '**/*.cpp **/*.h **/*.inl',
        prune_dirs = antglob.prune_dirs + 'waf-* ./build' )
    for path in cpp_sources:
        _fix_source_eol( path, is_dry_run )


def dry_fix(context):
    _do_fix( is_dry_run = True )

def fix(context):
    _do_fix( is_dry_run = False )

def shutdown():
    pass

def check(context):
    # Unit tests are run when "check" target is used
    ut = UnitTest.unit_test()
    ut.change_to_testfile_dir = True
    ut.want_to_see_test_output = True
    ut.want_to_see_test_error = True
    ut.run()
    ut.print_results()
